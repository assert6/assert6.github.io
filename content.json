{"meta":{"title":"断言说-断言很溜","subtitle":"断言怎么说","description":"","author":"张城铭","url":"https://assert6.github.io","root":"/"},"pages":[{"title":"","date":"2023-09-25T02:53:40.066Z","updated":"2023-09-25T02:53:40.066Z","comments":true,"path":"about/index.html","permalink":"https://assert6.github.io/about/index.html","excerpt":"","text":"张城铭 Hyperf 开发组成员, 前Swoft 开发组成员 曾任KK集团 | 深圳后端组负责人 (2021.07 - 2023.02)负责全集团后端岗位技术初面, 近一年筛选简历400+ 面试150+担任KK讲师, 为后端同事提供技术培训, 著有《Hyperf 正确打开方式》、《手把手拆解Hyperf》制定后端工作流程规范, 梳理CodeReview 规范及模板, 通过安利快捷键及扩展, 提高全员开发效率开展IDP 面谈, 进一步激发团队成员的目标感, 提高团队主动性和Owner 意识 KK集团 | 电商中台部技术负责人 (2018.12 - 2021.07)负责电商中台部系统技术架构选型, 参与团队日常需求及技术方案评审主导完成原FPM 框架迁移Hyperf、单体架构拆分微服务架构、分布式事务解决方案等重难点技术突破兼任系统运维工作, 完成生产环境Swarm 迁移K8s 集群, 搭建线上环境自动部署、监控、日志、报警等运维工作 前海果树财富 | 后端工程师 (2018.03 - 2018.12)负责公司业务系统的开发、维护及运维工作参与公司业务系统的技术选型、架构设计、技术方案评审参与公司业务系统的性能优化、安全加固、代码重构等工作 项目经验深度参与新零售行业全链路项目开发, 涵盖零售终端POS 系统、电商系统、供应链系统、仓储系统、ERP 系统, 以及客制化系统的商业化转型经验; FPM 框架迁移Hyperf 项目背景 2019年之前, 公司电商业务系统采用FPM 框架开发, 由于FPM 同步阻塞的模型决定了性能无法得到数量级的提升, 框架整体已经无法满足公司电商业务系统的快速发展需求 此时每逢业务高峰期, 业务系统的响应时间都会达到秒级, 严重影响用户体验, 甚至导致业务系统宕机, 严重影响公司业务 在此背景下, 由我主导将公司电商业务系统迁移Hyperf 框架, 以期实现业务系统的性能提升 项目亮点 通过Hyperf 框架的协程模型, 使得业务系统性能得到数量级的提升, 业务系统QPS 从原来的300+ 提升到了3000+ 在经过半年的使用过程中, 业务系统稳定性得到了大幅度的提升, 平稳度过618 大促后, Hyperf 在620 开源 摸索出了FPM 框架迁移Hyperf 的最佳实践, 也是首个Hyperf 框架的生产环境应用, 为公司业务系统的快速发展提供了可靠的技术保障 单体架构拆分微服务 项目背景 公司电商业务系统在迁移Hyperf 之初, 还是保持单体架构开发, 由于单体架构的代码耦合度高, 业务系统的扩展性差, 庞大的单体代码库已经严重限制了业务系统的快速迭代 庞大的代码库导致无法快速编译, 在Hyperf 2 版本时, 冷启动一次需要7分钟, 严重影响开发效率, 甚至导致修复线上BUG 时无法快速发布上线 单体架构的弹性伸缩能力差, 单个业务模块的性能瓶颈会拖累整个业务系统的性能, 只能整体扩容无法针对单模块扩容, 浪费了大量的服务器资源 项目亮点 通过微服务架构, 将庞大的单体代码库拆分成多个微服务, 弹性伸缩能力、开发效率、稳定性得到大幅度的提升, 也加强了业务系统的快速迭代能力 服务间采用serialize 协议的RPC 调用, 与传统JSON RPC 调用相比, 参数可以传递对象, 更加面向对象, 代码更简洁易理解, 更适合团队协作开发 通过开发熔断、降级、链路追踪等逻辑, 在业务流量洪峰时, 保证了微服务架构的稳定性, 也顺势开源相关组件代码, 为社区贡献了一份力量 电商小程序平台化 项目背景 在KK 品牌电商业务整体蓬勃发展的背景下, 集团内的TheColorist、X11、调色之家等线下零售品牌, 也开始筹措资源, 准备发展线上电商业务 为了统一管理线上电商业务, 集团内的各个品牌, 都需要开发自己的电商小程序, 但是各个品牌的电商小程序业务数据要求相互隔离, 不能相互影响 前期进行了调研, 各品牌小程序独立部署会导致大量资源浪费, 全面SaaS 化的方案则投入大风险高, 无法快速迭代, 最终选择了平台化的方案 项目亮点 通过平台化的方案, 将各个品牌的电商小程序业务数据隔离, 但是共享同一套基础设施, 降低了资源浪费, 也节省了运维成本 在后续搭建新的零售品牌电商小程序时, 只需要在原有系统进行配置, 就可以快速搭建出一个全新的电商小程序, 不到一周即可上线 平台化组件通过Hyperf AOP及DI 功能, 在不修改原有业务代码的情况下, 将底层的平台化逻辑注入到各个服务中, 降低了开发者的学习成本 Agent 代理商服务 项目背景 在三年疫情的影响下, 整个零售行业收入出现下滑, 此时线上电商的战略方向必须从有调性的宣传转变为增加实际营收, 成为公司业绩的另一个重要支柱 自营小程序的流量虽然有逐步提升, 但是远远无法与淘宝、京东、天猫等第三方平台企及, 必须通过第三方平台的流量, 才能实现线上电商的快速发展 如何通过技术支撑, 给运营团队提供更好的工具, 从而实现电商战略的U型转弯, 是技术团队需要思考的问题 项目亮点 通过对第三方平台接入流程的抽象, 将第三方平台抽象为一个个的Adapter, 通过Interface 约束, 使得开发同事后续接入第三方平台时, 只需要实现对应的接口, 就可以快速完成订单同步、商品同步、商品库存同步等功能 通过Hyperf AOP功能, 封装了@Shop 注解, 可以无感的将各个平台账号注入到业务逻辑中, 自动遍历平台账号维度, 执行对应的业务逻辑 国内已接入小红书、京东、得物、抖音、天猫、拼多多, 国外覆盖ShopOnline、Tokopedia、Tiktok、Lazada、Shopee, 未来还会继续扩展更多的平台 Agent 代理商服务上线短短一年, 营业额已经超过了自营电商小程序, 与运营团队一起实现了公司的电商战略U型转弯 我能提供如果是初创公司, 可以满足从初创到上市前的技术把控, 涵盖技术选型、架构设计、技术方案评审及开发、服务部署、线上运维等;如果是行业翘楚, 可以参与需求研发、系统重构, 开展内部技术培训, 规范工作流程及推动内源项目, 带动团队成员的技术成长; 联系我 微信: assert666 邮箱: &#122;&#x40;&#104;&#x79;&#x70;&#101;&#114;&#x66;&#x2e;&#x69;&#x6f; Github: https://github.com/assert6 博客: https://assert6.com/"},{"title":"标签","date":"2023-09-25T02:53:40.066Z","updated":"2023-09-25T02:53:40.066Z","comments":true,"path":"tags/index.html","permalink":"https://assert6.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"遇到的新问题 , 先挖坑","slug":"TODO","date":"2023-09-25T02:53:40.050Z","updated":"2023-09-25T02:53:40.050Z","comments":true,"path":"2023-09-25/TODO/","link":"","permalink":"https://assert6.github.io/2023-09-25/TODO/","excerpt":"","text":"声波牵引束 WebGL 挖矿 隐写术 casperjs FPM 迁移Hyperf 解决方案 Hyperf Swoole 迁移Swow 解决方案","categories":[],"tags":[]},{"title":"【Hyperf 入门到精通】AOP 02","slug":"hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】AOP 02","date":"2023-09-14T16:00:00.000Z","updated":"2023-09-25T02:53:40.050Z","comments":true,"path":"2023-09-14/hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】AOP 02/","link":"","permalink":"https://assert6.github.io/2023-09-14/hyperf/Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E3%80%90Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91AOP%2002/","excerpt":"","text":"AOP 使用入门及适用场景AOP 与Middleware 非常相似, 当你熟练掌握Middleware 时, 相当于也掌握了AOP我们先回顾下Middleware 调用流程:可以通过配置或者注解使用Middleware 123456789Router::get(&#x27;/&#x27;, &#x27;App\\Controller\\IndexController::index&#x27;, [&#x27;middleware&#x27; =&gt; [CorsMiddleware::class]]);#[Middleware(CorsMiddleware::class)]class IndexController&#123; ...&#125; Middleware 作为解耦神器, 非常普遍的应用在各个服务中但是, 这么好用的功能仅能作用在Controller 上, 岂不是很可惜? AOP 可以简单理解为, 可以作用在任何Class 的Middleware: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152use Hyperf\\Di\\Aop\\ProceedingJoinPoint;class A&#123; public function test() &#123; echo &#x27;this A&#x27;.PHP_EOL; &#125;&#125;class B&#123; public function test() &#123; (new A())-&gt;test(); echo &#x27;this B&#x27;.PHP_EOL; &#125;&#125;(new B())-&gt;test();class AOP&#123; public array $classes = [ A::class, B::class, ]; public function process(ProceedingJoinPoint $proceedingJoinPoint) &#123; $className = $proceedingJoinPoint-&gt;className; $methodName = $proceedingJoinPoint-&gt;methodName; echo &quot;&#123;$className&#125;::&#123;$methodName&#125; Before&quot;.PHP_EOL; # 相当于 $handler-&gt;handle($request); $result = $proceedingJoinPoint-&gt;process(); echo &quot;&#123;$className&#125;::&#123;$methodName&#125; After&quot;.PHP_EOL; return $result; &#125;&#125;// B::test Before// A::test Before// this A// A::test After// this B// B::test After AOP 使用场景有哪些? 可以思考Middleware 使用场景有哪些: Token 鉴权 签名&#x2F;验签, 加密&#x2F;解密 日志&#x2F;Tracer CORS …. 以上场景抽象一下, 得到结论: Middleware 适用于系统功能 同理, AOP 也适用于以上场景, 以及各种系统功能 Cacheable AsyncQueueMessage Retry Breaker Transaction RateLimit … 以常用的事务举例 1234567891011121314151617181920212223242526272829303132use Hyperf\\DbConnection\\Db;class A&#123; // 普通写法 public function foo() &#123; Db::beginTransaction(); try&#123; $model = Model::query()-&gt;where(&#x27;id&#x27;, 1)-&gt;first(); $model-&gt;name = &#x27;Hyperf&#x27;; $model-&gt;save(); Db::commit(); &#125; catch(\\Throwable $e)&#123; Db::rollBack(); &#125; return $model; &#125; // 闭包写法 public function bar() &#123; return Db::transaction(function () &#123; $model = Model::query()-&gt;where(&#x27;id&#x27;, 1)-&gt;first(); $model-&gt;name = &#x27;Hyperf&#x27;; $model-&gt;save(); return $model; &#125;); &#125;&#125; AOP 搭配注解写法 12345678910111213141516171819202122232425262728293031use Hyperf\\DbConnection\\Annotation\\Transactional;class A&#123; #[Transactional] public function test() &#123; $model = Model::query()-&gt;where(&#x27;id&#x27;, 1)-&gt;first(); $model-&gt;name = &#x27;Hyperf&#x27;; $model-&gt;save(); return $model; &#125;&#125;// 讲解说明, 非实际代码class TransactionAspect&#123; public array $annotations = [ Transactional::class, ]; public function process(ProceedingJoinPoint $proceedingJoinPoint) &#123; return Db::transaction(function () use ($proceedingJoinPoint) &#123; return $proceedingJoinPoint-&gt;process(); &#125; ); &#125;&#125; 单一场景下, 闭包写法与注解AOP 差别不大 但如果此时需要加需求, 易读性会截然不同: 123456789101112131415class A&#123; public function bar() &#123; return Cache::remember(function () &#123; Db::transaction(function () &#123; $model = Model::query()-&gt;where(&#x27;id&#x27;, 1)-&gt;first(); $model-&gt;name = &#x27;Hyperf&#x27;; $model-&gt;save(); return $model; &#125;); &#125;); &#125;&#125; 123456789101112class A&#123; #[Cacheable] #[Transactional] public function test() &#123; $model = Model::query()-&gt;where(&#x27;id&#x27;, 1)-&gt;first(); $model-&gt;name = &#x27;Hyperf&#x27;; $model-&gt;save(); return $model; &#125;&#125; AOP 避免回调地狱, 举例, 非正常业务场景 123456789101112131415class A&#123; #[Transactional] #[Cacheable] #[AtomicLock] #[Retry] #[RateLimit(create: 1, capacity: 3)] public function test() &#123; $model = Model::query()-&gt;where(&#x27;id&#x27;, 1)-&gt;first(); $model-&gt;name = &#x27;Hyperf&#x27;; $model-&gt;save(); return $model; &#125;&#125;","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"入门到精通","slug":"入门到精通","permalink":"https://assert6.github.io/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"}]},{"title":"【Hyperf 入门到精通】优雅范式 05","slug":"hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】优雅范式 05","date":"2023-09-14T16:00:00.000Z","updated":"2023-09-25T02:53:40.050Z","comments":true,"path":"2023-09-14/hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】优雅范式 05/","link":"","permalink":"https://assert6.github.io/2023-09-14/hyperf/Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E3%80%90Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91%E4%BC%98%E9%9B%85%E8%8C%83%E5%BC%8F%2005/","excerpt":"","text":"优雅编程范式新增代替修改 AOP 与Event","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"入门到精通","slug":"入门到精通","permalink":"https://assert6.github.io/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"}]},{"title":"【Hyperf 入门到精通】协程 04","slug":"hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】协程 04","date":"2023-09-14T16:00:00.000Z","updated":"2023-09-25T02:53:40.050Z","comments":true,"path":"2023-09-14/hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】协程 04/","link":"","permalink":"https://assert6.github.io/2023-09-14/hyperf/Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E3%80%90Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91%E5%8D%8F%E7%A8%8B%2004/","excerpt":"","text":"子协程的适用场景Swoole&#x2F;Swow 对比Python 及Nodejs 协程, 最大特点是可以无侵入, 润物细无声 甚至绝大多数代码可以无缝由Laravel 复制到Hyperf, 直接获得几个数量级的性能提升 使用子协程的缺点: 事务性无法保证 顺序性无法保证 理解成本高(需要明确知道哪些会触发协程切换) 对端压力大 子协程的优点:$time &#x3D; x_1+x_2+x_3+….x_n$$time &#x3D; max(x_1,x_2,x_3,…x_n)$ 提高响应速度 提高响应速度 提高响应速度 综上所述, 在哪些场景推荐使用子协程呢?在不需要事务性保证、顺序性没有影响、对子协程有一定理解、对端可以承受大并发、急需提高响应速度的场景中 爬虫 123456789101112131415use Hyperf\\Engine\\Coroutine;Coroutine::run(function () &#123; echo &quot;1&quot;; Coroutine::create(function () &#123; echo &quot;2&quot;; sleep(1); // 触发协程调度 echo &quot;3&quot;; &#125;); Coroutine::create(function () &#123; echo &quot;4&quot;; &#125;);&#125;);\\Swow\\Sync\\waitAll(); 非必要不使用子协程 TODO 手动使用子协程","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"入门到精通","slug":"入门到精通","permalink":"https://assert6.github.io/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"}]},{"title":"【Hyperf 入门到精通】注解 01","slug":"hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】注解 01","date":"2023-09-14T16:00:00.000Z","updated":"2023-09-25T02:53:40.050Z","comments":true,"path":"2023-09-14/hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】注解 01/","link":"","permalink":"https://assert6.github.io/2023-09-14/hyperf/Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E3%80%90Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91%E6%B3%A8%E8%A7%A3%2001/","excerpt":"","text":"注解 Annotation &#x2F; AttributePHP8 之前注解称之为Annotation使用doctrine/annotations组件, 通过特定文本格式@Class解析内容, 已经淘汰这里不展开 12345678910use Hyperf\\HttpServer\\Annotation\\Controller;/** * @Controller(...) */class IndexController&#123; &#125; PHP8 之后注解称之为Attribute, PHP 官方提供, 使用方便, 性能优秀, 格式为#[Class] 123456789101112131415use Hyperf\\HttpServer\\Annotation\\Controller;#[Controller(prefix: &#x27;/index&#x27;)]class IndexController&#123; &#125;# 反射获取属性$reflectionClass = new ReflectionClass(IndexController::class);$attributes = $reflectionClass-&gt;getAttributes();foreach ($attributes as $attribute) &#123; print_r([$attribute-&gt;getName(), $attribute-&gt;getArguments()]);&#125; 官方介绍: Attribute 提供了在代码中的声明上添加结构化、机器可读的元数据信息的能力：类、方法、函数、参数、属性和类常量可以是Attribute 的目标。然后可以使用反射 API在运行时检查Attribute 定义的元数据 。因此，Attribute 可以被认为是直接嵌入到代码中的配置语言。 注解可以简单理解为, 写死在代码(类、方法、函数、参数、属性和类常量)上的配置项 自定义一个Attribute12345678910use Attribute;#[Attribute(Attribute::TARGET_CLASS_CONSTANT)]class Message&#123; public function __construct(public string $text) &#123; &#125;&#125; 可以实现一个简易版枚举类 123456789101112131415161718192021222324use Message;class ErrorCode&#123; #[Message(&#x27;成功&#x27;)] public const SUCCESS = 0; #[Message(&#x27;系统参数错误&#x27;)] public const ERROR = 1; public static function getMessage(int $code): string &#123; $reflectionClass = new ReflectionClass(ErrorCode::class); $constants = $reflectionClass-&gt;getReflectionConstants(); foreach ($constants as $constant) &#123; if ($constant-&gt;getValue() === $code) &#123; $attributes = $constant-&gt;getAttributes(Message::class); return $attributes[0]-&gt;newInstance()-&gt;text; &#125; &#125; return &#x27;&#x27;; &#125;&#125;echo ErrorCode::getMessage(ErrorCode::SUCCESS); 注意, Hyperf 自带的一些注解, 功能强大, 比如: Inject Controller Cacheable 但这是因为AOP 的强大, 并非注解强大, 后面介绍AOP","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"入门到精通","slug":"入门到精通","permalink":"https://assert6.github.io/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"}]},{"title":"【Hyperf 入门到精通】生命周期 03","slug":"hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】生命周期 03","date":"2023-09-14T16:00:00.000Z","updated":"2023-09-25T02:53:40.050Z","comments":true,"path":"2023-09-14/hyperf/Hyperf 入门到精通/【Hyperf 入门到精通】生命周期 03/","link":"","permalink":"https://assert6.github.io/2023-09-14/hyperf/Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E3%80%90Hyperf%20%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2003/","excerpt":"","text":"生命周期与变量作用范围Laravel 生命周期是由FPM 决定的, 同样Hyperf 生命周期是由Swoole 生命周期决定的 以HTTP 服务为例, 通过代码解释一下生命周期, 如果使用不当, 会造成内存泄漏、数据混淆, 引发生产事故 全局生命周期(进程生命周期) 请求生命周期 协程生命周期 12345678910111213141516171819require_once __DIR__ . &#x27;/vendor/autoload.php&#x27;;use Hyperf\\Engine\\Http\\Server;use Hyperf\\HttpMessage\\Server\\Response;use Psr\\Http\\Message\\ServerRequestInterface;use Swow\\Psr7\\Server\\ServerConnection;$a = 0;$server = new Server();$server-&gt;bind(&#x27;0.0.0.0&#x27;, 9502);$server-&gt;handle(function (ServerRequestInterface $request, ServerConnection $connection) &#123; $b = 0; $response = new Response(); $connection-&gt;sendHttpResponse($response-&gt;withContent(&#x27;Hello World&#x27;))-&gt;close();&#125;);$server-&gt;start(); 全局生命周期, 内存里一直存在, 程序结束才会释放 start() 前赋值的变量 类静态属性 超全局变量 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phprequire_once __DIR__ . &#x27;/vendor/autoload.php&#x27;;use Hyperf\\Engine\\Http\\Server;use Hyperf\\HttpMessage\\Server\\Response;use Psr\\Http\\Message\\ServerRequestInterface;use Swow\\Psr7\\Server\\ServerConnection;class Count&#123; public static int $count = 0;&#125;$count = 0;$globalCount = 0;$_GET[&#x27;count&#x27;] = 0;$server = new Server();$server-&gt;bind(&#x27;0.0.0.0&#x27;, 9502);$server-&gt;handle(function (ServerRequestInterface $request, ServerConnection $connection) use (&amp;$count) &#123; global $globalCount; // start() 前声明的变量 $globalCount++; $count++; // 类静态变量 Count::$count++; // 超全局变量 $_GET[&#x27;count&#x27;]++; echo &quot;Global \\$count: &#123;$globalCount&#125;\\n&quot;; echo &quot;Global \\$globalCount: &#123;$globalCount&#125;\\n&quot;; echo &quot;Global Count::count &quot; . Count::$count . &quot;\\n&quot;; echo &quot;Global \\$_GET &#123;$_GET[&#x27;count&#x27;]&#125; \\n&quot;; $connection-&gt;sendHttpResponse((new Response())-&gt;withContent(&#x27;Hello World&#x27;))-&gt;close();&#125;);$server-&gt;start(); 代码生命周期小于变量作用范围才可能出现内存泄漏比如请求生命周期内, 操作全局变量 12345678910111213141516171819require_once __DIR__ . &#x27;/vendor/autoload.php&#x27;;use Hyperf\\Engine\\Http\\Server;use Hyperf\\HttpMessage\\Server\\Response;use Psr\\Http\\Message\\ServerRequestInterface;use Swow\\Psr7\\Server\\ServerConnection;$globalCount = [];$server = new Server();$server-&gt;bind(&#x27;0.0.0.0&#x27;, 9502);$server-&gt;handle(function (ServerRequestInterface $request, ServerConnection $connection) &#123; global $globalCount; $globalCount[] = $request; $connection-&gt;sendHttpResponse((new Response())-&gt;withContent(&#x27;Hello World&#x27;))-&gt;close();&#125;);$server-&gt;start(); 注意, 上述代码中的$request本身是请求生命周期, 但是赋值给全局生命周期的变量, 导致变量作用范围逃逸 举个常用的例子 1234567891011121314151617181920namespace App\\Controller;use Hyperf\\HttpServer\\Annotation\\Controller;use Hyperf\\HttpServer\\Annotation\\GetMapping;#[Controller]class IndexController extends AbstractController&#123; public int $count = 0; #[GetMapping(&quot;/add&quot;)] public function add() &#123; echo $this-&gt;count++, PHP_EOL; sleep(1); return $this-&gt;count; &#125;&#125; 为什么以上代码会出现数据混淆? 其实$count 作用范围隶属于IndexController 的IndexController 从$container-&gt;$resolvedEntries 获取$container 在Swoole::start() 前声明, 所以是全局生命周期变量ApplicationContext::getContainer() 只是方便使用, 并不是根本原因","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"入门到精通","slug":"入门到精通","permalink":"https://assert6.github.io/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"}]},{"title":"【手把手教你】Hyperf 接入OpenAI ChatGPT","slug":"hyperf/【手把手教你】Hyperf 接入OpenAI (ChatGPT)","date":"2023-03-27T16:00:00.000Z","updated":"2023-09-25T02:53:40.054Z","comments":true,"path":"2023-03-27/hyperf/【手把手教你】Hyperf 接入OpenAI (ChatGPT)/","link":"","permalink":"https://assert6.github.io/2023-03-27/hyperf/%E3%80%90%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E3%80%91Hyperf%20%E6%8E%A5%E5%85%A5OpenAI%20(ChatGPT)/","excerpt":"","text":"OpenAI 是什么OpenAI是一家致力于人工智能研究和发展的公司，其目标是创建普适人工智能，能够为人类创造更加繁荣、安全和可持续的未来。 为了实现这一目标，OpenAI不仅开展基础研究，还提供各种人工智能相关的工具和服务，包括API接口，以方便开发者快速应用最新的人工智能技术。 OpenAI APIOpenAI API是一种面向开发者的人工智能服务，提供各种语言模型和自然语言处理工具。开发者可以使用OpenAI API来创建智能应用程序，例如聊天机器人、文本摘要器和情感分析器等。 目前，OpenAI API提供了以下几种模型： GPT-3：目前最大的语言模型，可生成高质量的自然语言文本。 DALL-E：一种基于GPT-3的图像生成模型，可以根据文本输入生成独特的图像。 CLIP：一种视觉模型，可以通过图片识别标签和描述，用于图像分类、搜索和相似度匹配。 Codex：一个基于GPT-3的代码生成模型，可以通过简短的自然语言指令生成代码。 Triton：一种用于推荐系统和个性化推荐的模型。使用OpenAI API需要先注册一个开发者账户并创建API密钥。注册成功后，开发者可以使用API密钥来调用OpenAI API提供的各种服务。 接入OpenAI API以下是接入OpenAI API的一般步骤： 注册开发者账户并创建API密钥。在OpenAI网站上注册并创建一个API密钥，用于调用API服务。 安装OpenAI API SDK。OpenAI提供了各种语言的SDK，包括Python、JavaScript、Java、Ruby等，开发者可以选择适合自己的SDK进行安装。 调用API服务。使用SDK提供的API接口和密钥，开发者可以调用OpenAI API提供的各种服务。 注意, 以上全部是由OpenAI ChatGPT生成 Hyperf 接入OpenAI接入OpenAI 的步骤非常简单, 上面ChatGPT 也已经给出了大概步骤, 下面举例展示一下, 重点在于类似ChatGPT 逐字回复的EventStream 的实现. 生成API密钥我们需要在OpenAI官网注册一个账号, 然后生成一个API密钥, 保存好后面会用到, 注册账号的教程非常多, 这里就不再赘述了. 安装OpenAI SDKOpenAI 官方提供了PHP SDK, 但要求PHP 8.1+ 版本, 满足要求的话可以直接安装使用 1composer require openai-php/client 或者基于Hyperf 封装的Client组件 1composer require friendsofhyperf/openai-client SDK 代码非常清晰, 这里以官方SDK为例, 创建Client 配置参数即可请求OpenAI, 各个参数的含义可以参考官方文档 1234567891011public function index()&#123; $client = OpenAI::client(&#x27;替换第一步生成的API密钥&#x27;); $response = $client-&gt;completions()-&gt;create([ &#x27;model&#x27; =&gt; &#x27;text-davinci-003&#x27;, &#x27;prompt&#x27; =&gt; &#x27;Hyperf 是什么?&#x27;, &#x27;max_tokens&#x27; =&gt; 2048, ]); return $response-&gt;toArray();&#125; 启动Hyperf 后调用一下, 就可以看到OpenAI 的回复了 逐字回复 EventStream完成上面的步骤后, 会发现等待响应大概6秒左右特别久, 是因为我们同步阻塞等待OpenAI 所有响应, 在全部发送给客户端,而ChatGPT 采用了EventStream可以异步响应逐字回复, 所以在等待回复时可以看到ChatGPT 正在处理请求, 这样体验会更好一些.同样Hyperf 最新版本也支持了EventStream, 可以非常方便的实现逐字回复.稍微修改下上面的代码 12345678910111213141516171819202122public function index()&#123; $client = OpenAI::client(&#x27;替换第一步生成的API密钥&#x27;); // 注意这里改为了createStreamed 方法 $result = $client-&gt;completions()-&gt;createStreamed([ &#x27;model&#x27; =&gt; &#x27;text-davinci-003&#x27;, &#x27;prompt&#x27; =&gt; &#x27;Hyperf 是什么?&#x27;, &#x27;max_tokens&#x27; =&gt; 2048, ]); // 如果报错Argument #1 ($connection) must be of type Hyperf\\Engine\\Contract\\Http\\Writable // 或者没有\\Hyperf\\Engine\\Http\\EventStream // 请更新engine(v1.10.0或v2.8.0)、engine-contract(v1.7.0)、hyperf/http-server(v3.0.14) $response = ApplicationContext::getContainer()-&gt;get(\\Hyperf\\HttpServer\\Contract\\ResponseInterface::class); $eventStream = new \\Hyperf\\Engine\\Http\\EventStream($response-&gt;getConnection()); foreach ($result as $stream) &#123; $eventStream-&gt;write($stream[&#x27;choices&#x27;][0][&#x27;text&#x27;]); &#125; $eventStream-&gt;end();&#125; 注意代码改动了三处, 其中第一处是create 方法改为createStreamed 方法, 第二处是去掉了返回值return $response-&gt;toArray(), 第三处是使用EventStream 逐字响应.启动Hyperf 后调用一下, 就可以看到OpenAI 的回复了, 并且可以看到逐字响应的效果: PS: mozilla EventStream 格式","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://assert6.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://assert6.github.io/tags/OpenAI/"}]},{"title":"Windows 原生环境开发Hyperf","slug":"hyperf/Windows 原生环境开发Hyperf","date":"2023-02-27T16:00:00.000Z","updated":"2023-09-25T02:53:40.054Z","comments":true,"path":"2023-02-27/hyperf/Windows 原生环境开发Hyperf/","link":"","permalink":"https://assert6.github.io/2023-02-27/hyperf/Windows%20%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91Hyperf/","excerpt":"","text":"很多同学在开发Hyperf 时, 会选择使用Docker, 但是Docker 在Windows 下的体验并不是很好, 有时候会出现各种各样的问题, 本文将介绍如何在Windows 原生环境下开发Hyperf Box 介绍 Box 致力于帮助提升 PHP 应用程序的编程体验，尤其有助于 Hyperf 应用，管理 PHP 环境和相关依赖，同时提供将 PHP 应用程序打包为二进制程序的能力，还提供反向代理服务来管理和部署 Swoole&#x2F;Swow 服务 管理PHP 版本及依赖, 规避多个PHP版本并存时兼容问题 打包代码为二进制程序, 一个.exe文件直接跑起来 反向代理(不是重点🤣) 安装以Windows 为例, 直接从Github releases 下载对应的二进制文件, 注意后续版本可能会有变化, 自行下载最新版本或执行box self-update 升级 正如官方文案所说, 下载的Box.exe 自身就是一个基于Box 打包出来的Hyperf 应用, 轻松实现自举 执行box build-prepare 初始化Box 所需的依赖, 梯子请自备 使用Box 下载完成后, 即可使用Box 的Composer 来安装Hyperf , 这里选用Swow 版本骨架 1box composer create-project hyperf/swow-skeleton 耐心等待, 安装完成后, 进入项目目录, 执行 123box php .\\bin\\hyperf.php start// 也可以使用box hyperf start 启动项目成功后, 可以愉快的在Windows 下开发Hyperf 了! 打包打包是Box 另一项神奇的能力, 必须要尝试一下 当我们开发完成后, 可以使用Box 打包成二进制文件, 以便于交付部署 1box build 打包完成后, 当前路径会出现一个名为hyperf.exe 的二进制文件，后续只需要通过hyperf start 命令即可启动该 Hyperf 应用 本文也算标题党了, 因为Box 了解的人还是非常少的, 但Windows 下开发Hyperf 的需求很多, 所以引申出Box 的使用 当然目前Box 还是个实验品, 有许多改进的空间, 有兴趣的同学可以参与进来, 一起完善Box, 全部都由PHP 代码实现, 认真看一下就可以参与贡献了","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"Box","slug":"Box","permalink":"https://assert6.github.io/tags/Box/"},{"name":"Windows","slug":"Windows","permalink":"https://assert6.github.io/tags/Windows/"}]},{"title":"一分钟搭建Hyperf","slug":"一分钟搭建Hyperf","date":"2019-07-10T16:00:00.000Z","updated":"2023-09-25T02:53:40.062Z","comments":true,"path":"2019-07-10/一分钟搭建Hyperf/","link":"","permalink":"https://assert6.github.io/2019-07-10/%E4%B8%80%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BAHyperf/","excerpt":"","text":"前置依赖 Docker Git PHPStorm 计时开始1.下载Hyperf Docker 镜像1docker pull hyperf/hyperf 2.下载Hyperf1git clone https://github.com/hyperf/hyperf-skeleton.git 3.等待下载完成 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 98% 4.配置PHPStorm打开hyperf-skeleton, 如下图所示配置PHPStorm 如果Server 选项里无法找到Docker,可能是Docker 没有暴露守护进程 点击配置旁边的运行按钮, 如下图示说明容器已经欢快的运行起来了 5.安装Composer 组件进入刚才部署的容器 1docker exec -it hyperf /bin/bash 进入容器后运行 1cd /home &amp;&amp; composer install 这一步到了安装Hyperf 组件的界面, 有需要的可以选择安装, 不需要可以全选n 安装完成后运行php bin/hyperf.php start, 然后打开浏览器请求http://127.0.0.1:9501 完成! 6.最后配置中的Command修改为php /home/bin/hyperf.php start, 就可以愉快的一键重启了","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"}]},{"title":"【手把手教你】Swoft 多库连接池配置","slug":"swoft/Swoft 多库连接池配置","date":"2018-09-26T16:00:00.000Z","updated":"2023-09-25T02:53:40.058Z","comments":true,"path":"2018-09-26/swoft/Swoft 多库连接池配置/","link":"","permalink":"https://assert6.github.io/2018-09-26/swoft/Swoft%20%E5%A4%9A%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE/","excerpt":"","text":"这里的多库是指数据不同的两个主库 并不是数据相同的主从库 多库的配置非常简单, 只涉及到配置文件和两个类PoolConfig Pool 配置文件编辑配置文件 config/properties/db.php新增数据库配置 1234567891011121314&#x27;dev&#x27; =&gt; [ &#x27;master&#x27; =&gt; [ &#x27;name&#x27; =&gt; &#x27;master2&#x27;, &#x27;uri&#x27; =&gt; [ &#x27;192.168.1.135:3306/test?user=tender&amp;password=123456&amp;charset=utf8&#x27;, ], ], &#x27;slave&#x27; =&gt; [ &#x27;name&#x27; =&gt; &#x27;slave3&#x27;, &#x27;uri&#x27; =&gt; [ &#x27;192.168.1.135:3306/test?user=tender&amp;password=123456&amp;charset=utf8&#x27;, ], ],], 加完如下 默认的master和slave应为default下的配置, 为了兼容历史版本 连接池配置类新建app/Pool/Config/DevPoolConfig.php 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Pool\\Config;use Swoft\\Bean\\Annotation\\Bean;use Swoft\\Bean\\Annotation\\Value;use Swoft\\Db\\Pool\\Config\\DbPoolProperties;/** * DevPoolConfig * @Bean() */class DevPoolConfig extends DbPoolProperties&#123; /** * @Value(name=&quot;$&#123;config.db.dev.master.name&#125;&quot;) * @var string */ protected $name = &#x27;&#x27;; /** * @Value(name=&quot;$&#123;config.db.dev.master.uri&#125;&quot;) * @var array */ protected $uri = [];&#125; 连接池配置类只是把配置文件由数组改写为类, 有其他配置需要全部加进去。 这里只改了name 和uri 连接池新建app/Pool/DevPool.php 12345678910111213141516171819202122&lt;?phpnamespace App\\Pool;use App\\Pool\\Config\\DevPoolConfig;use Swoft\\Bean\\Annotation\\Inject;use Swoft\\Bean\\Annotation\\Pool;use Swoft\\Db\\Pool\\DbPool;/** * DevPool * * @Pool(&quot;dev.master&quot;) */class DevPool extends DbPool&#123; /** * @Inject() * @var DevPoolConfig */ public $poolConfig;&#125; 更简单, 指定该连接池使用哪个配置注意下@Pool 注解连接池别名, 要带.master或者.salve 使用连接池有两种方法使用连接池第一种是在实体类@Entity 注解里配置instance字段: 12345678/** * 用户实体 * @Entity(instance=&quot;dev.master&quot;) * @Table(name=&quot;user&quot;) */class User extends Model&#123;... 这样调用该实体就会走dev的配置 第二种是在Db::query() 查询时指定连接池, 直接在方法第三个参数配置即可: 1Db::query(&quot;show databases;&quot;,[], &#x27;dev.master&#x27;)-&gt;getResult();","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"【手把手教你】自定义Swoft 注解和AOP","slug":"swoft/自定义Swoft 注解和AOP","date":"2018-07-19T16:00:00.000Z","updated":"2023-09-25T02:53:40.058Z","comments":true,"path":"2018-07-19/swoft/自定义Swoft 注解和AOP/","link":"","permalink":"https://assert6.github.io/2018-07-19/swoft/%E8%87%AA%E5%AE%9A%E4%B9%89Swoft%20%E6%B3%A8%E8%A7%A3%E5%92%8CAOP/","excerpt":"","text":"序言前两篇关于Swoft RPC 的使用教程得到很多小伙伴的支持 并且反映网上很多关于Swoft 的讲解太过于深♂入, 很多小伙伴看不懂 这是很正常的, 因为开发者们对于使用难度的理解跟我们有些偏差 身为开发者自然知道如何使用, 认为不需要讲解, 也就是所谓的知识的诅咒 所以很多关于Swoft 的讲解都是底层原理 那在这我就开一个大佬们不屑的新手向讲解教程 (￣_ ￣ ) 叫做[手把手教你]系列 只要跟着一点点练习, 熟练使用是没问题滴 前置技能 会使用Swoft 的MVC 使用了Swoft 的注解 理解注解只是配置的另一种展现方式 PHPStorm 安装了PHP Annotations 插件 下面就让我们开始吧 注解类想要定义一个注解是非常简单的 新建注解类app\\Module\\Test\\Annotations\\Test.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Module\\Test\\Annotations;/** * 测试注解 * @Annotation * @Target(&quot;ALL&quot;) */class Test&#123; /** * @var string 构造参数 */ private $name = &#x27;&#x27;; public function __construct(array $values) &#123; if (isset($values[&#x27;name&#x27;])) &#123; $this-&gt;name = $values[&#x27;name&#x27;]; &#125; &#125; /** * @return string */ public function getName(): string &#123; return $this-&gt;name; &#125; /** * @param string $name */ public function setName(string $name) &#123; $this-&gt;name = $name; &#125;&#125; 这里有三点需要注意: 1 类注解要加@Annotation, 用来声明这是一个注解类 2 类名不需要加Annotation后缀 3 类注解@Target()为Doctrine\\Common\\Annotations\\Annotation\\Target.php, 参数可以填ALL|CLASS|METHOD|PROPERTY|ANNOTATION, 表示该注解使用的级别, 类注解还是方法注解,属性注解,或者全部都能使用 这样我们自定义的注解标签就完成了 去IndexController.php里试一下 注意不要忘记use我们的注解类 注解类Test的@Target设置为ALL, 可以同时在类和方法上使用(属性也可以的) 为了体现使用了注解, 可以在注解类Test的构造函数中进行输出 重启一下程序 这样就是成功了, 输出多个是正常现象, 毕竟多进程, 也是Swoft高性能的原因 注解解析类 Parser正如前置技能里所说 注解只是配置的另一种展现方式 任何逻辑都不要在注解类里处理 新建注解解析类app\\Module\\Test\\Parser\\TestParser.php 1234567891011121314151617181920&lt;?phpnamespace App\\Module\\Test\\Parser;use App\\Module\\Test\\Collector\\TestCollector;use Swoft\\Bean\\Parser\\AbstractParser;class TestParser extends AbstractParser&#123; public function parser( string $className, $objectAnnotation = null, string $propertyName = &#x27;&#x27;, string $methodName = &#x27;&#x27;, $propertyValue = null ) &#123; TestCollector::collect($className, $objectAnnotation, $propertyName, $methodName, $propertyValue); &#125;&#125; 解释一下这几个参数的意义: $className 当前注解所在的类名 $objectAnnotation 当前注解所实例化的注解类new Test([name=&quot;666&quot;]) $propertyName 当前注解所在的属性名(如果是属性注解) $methodName 当前注解所在的方法名(如果是方法注解) $propertyValue 当前注解所在的属性(如果是属性注解) 这里也不要处理逻辑, 因为此刻程序还处于初始化阶段, 没有请求数据 注解解析类Parser只做了一件事, 就是把注解类存入注解收集类 什么是注解收集类呢? 注解收集类 Collector注解收集类Collector非常简单, 相当于一个全局数组方便我们后续处理而已 新建注解收集类app\\Module\\Test\\Collector\\TestCollector.php 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Module\\Test\\Collector;use Swoft\\Bean\\CollectorInterface;class TestCollector implements CollectorInterface&#123; private static $test = []; public static function collect( string $className, $objectAnnotation = null, string $propertyName = &#x27;&#x27;, string $methodName = &#x27;&#x27;, $propertyValue = null ) &#123; self::$test[$className][$methodName] = $objectAnnotation; &#125; public static function getCollector() &#123; return self::$test; &#125;&#125; 正如所见, 只是存取$objectAnnotation注解实例, 方便我们后面使用 本篇举例的是方法注解, 所以默认$methodName不为空 注解收集类Collector被注解解析类Parser调用 那注解解析类Parser被谁调用呢? 注解封装类 Wrapper新建注解封装类app\\Module\\Test\\Wrapper\\TestWrapper.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace App\\Module\\Test\\Wrapper;use App\\Module\\Test\\Annotations\\Test;use Swoft\\Bean\\Wrapper\\AbstractWrapper;class TestWrapper extends AbstractWrapper&#123; /** * @var array 解析哪些注解(类级) */ protected $classAnnotations = []; /** * @var array 解析哪些注解(属性级) */ protected $propertyAnnotations = []; /** * @var array 解析哪些注解(方法级) */ protected $methodAnnotations = [ Test::class, ]; /** * 是否解析类注解 * @param array $annotations * @return bool */ public function isParseClassAnnotations(array $annotations): bool &#123; return false; &#125; /** * 是否解析属性注解 * @param array $annotations * @return bool */ public function isParsePropertyAnnotations(array $annotations): bool &#123; return false; &#125; /** * 是否解析方法注解 * @param array $annotations * @return bool */ public function isParseMethodAnnotations(array $annotations): bool &#123; return true; &#125;&#125; 当我们的类注解被实例化时, 会触发注解封装类&#123;注解标签名&#125;Wrapper 注解封装类Wrapper来决定是否触发注解解析类Parser 解释一下, 可能不好理解 这里isParseClassAnnotations 返回false, 意味着类注解略过不解析; 同理isParsePropertyAnnotations 返回false, 属性注解略过不解析; 而isParseMethodAnnotations 返回true,那么对应的$methodAnnotations里的注解类全部触发解析,这里的Test::class会触发对应的TestParser; 抽象的说, 注解封装类Wrapper回答了两个问题: 是否解析, 解析哪些 具象的说, 这里的封装类TestWrapper回答的就是:”只解析方法注解@Test“ 可以在注解解析类Parser的构造方法中进行输出 重启程序, 我们来看一下!这里可以看到, 在注解类Test里输出的内容还有类注解的666, 到了注解解析类TestParser, 就没有了666, 只有方法注解777 总结 实例化注解类Test, 询问注解封装类TestWrapper解析哪些注解 注解封装类TestWrapper回答解析方法上的Test, 于是方法级的注解Test被注解解析类TestParser存进了注解收集类TestCollector 注意!!!!程序只会主动扫描类注解, 然后扫描类注解Wrapper下指定的方法注解和属性注解!!如果你的方法注解不存在于任何类注解的Wrapper下, 则是不会被解析的!!如何使用收集完毕下面举例如何使用 中间件新建中间件app\\Module\\Test\\Middlewares\\TestMiddleware.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Module\\Test\\Middlewares;use App\\Module\\Test\\Annotations\\Test;use App\\Module\\Test\\Collector\\TestCollector;use Psr\\Http\\Message\\ResponseInterface;use Psr\\Http\\Message\\ServerRequestInterface;use Psr\\Http\\Server\\RequestHandlerInterface;use Swoft\\Bean\\Annotation\\Bean;use Swoft\\Core\\RequestContext;use Swoft\\Http\\Message\\Middleware\\MiddlewareInterface;/** * @Bean() */class TestMiddleware implements MiddlewareInterface&#123; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface &#123; echo &quot;in Middleware\\n&quot;; $response = $handler-&gt;handle($request); // 当前请求的控制器 $controllerClass = RequestContext::getContextDataByKey(&#x27;controllerClass&#x27;); // 当前请求的方法 $controllerAction = RequestContext::getContextDataByKey(&#x27;controllerAction&#x27;); $collector = TestCollector::getCollector(); /* @var Test $test*/ if ($test = $collector[$controllerClass][$controllerAction])&#123; print_r($test-&gt;getName().&quot; in Middleware\\n&quot;); &#125; return $response; &#125;&#125; 这里可以看到, 之前负责收集注解的注解收集类TestCollector 派上用处了, 可以非常方便的通过他获取到当前请求方法的注解信息 这需要注意, RequestContext::getContextDataByKey(&#39;controllerClass&#39;)获取请求控制器的方法要在$handler-&gt;handle($request)后才有值, 因为负责路由的中间件还没执行到XD 切勿忘记use 中间件 重启完访问一下试试 AOP 切面新建切面类app\\Module\\Test\\Aspect\\TestAspect.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace App\\Module\\Test\\Aspect;use App\\Module\\Test\\Collector\\TestCollector;use Swoft\\Aop\\ProceedingJoinPoint;use Swoft\\Bean\\Annotation\\Around;use Swoft\\Bean\\Annotation\\Aspect;use Swoft\\Bean\\Annotation\\PointAnnotation;use App\\Module\\Test\\Annotations\\Test;use Swoft\\Core\\RequestContext;/** * 测试切面类 * @Aspect() * @PointAnnotation( * include=&#123; * Test::class * &#125; * ) * @package App\\Module\\Test\\Aspect */class TestAspect&#123; /** * @Around() * @param ProceedingJoinPoint $proceedingJoinPoint * @return mixed */ public function around(ProceedingJoinPoint $proceedingJoinPoint) &#123; $controllerClass = RequestContext::getContextDataByKey(&#x27;controllerClass&#x27;); $controllerAction = RequestContext::getContextDataByKey(&#x27;controllerAction&#x27;); $collector = TestCollector::getCollector(); /* @var Test $test*/ $test = $collector[$controllerClass][$controllerAction]; echo $test-&gt;getName(), &quot;around-before\\n&quot;; $result = $proceedingJoinPoint-&gt;proceed(); echo $test-&gt;getName(), &quot;around-after\\n&quot;; return $result; &#125;&#125; @Aspect() 声明这是一个切面类 @PointAnnotation 设置了注解切入点 @Before() 设置了通知点 其他设置可以参考Swoft文档 AOP章节; 还需要改一下注解解析类TestParser 在parser 方法中加入Collector::$methodAnnotations[$className][$methodName][] = get_class($objectAnnotation); 这一步的作用是将使用注解的方法加入到允许切入的数组, 只有在Collector::$methodAnnotations变量中存在的方法才会调用切面 重启程序请求一下 控制器当然也可以在控制器用 个人还是推荐用切面, 控制器里只需要加入注解即可","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"记一次XSS漏洞(慕课网)","slug":"security/记一次XSS漏洞(慕课网)","date":"2018-06-28T16:00:00.000Z","updated":"2023-09-25T02:53:40.054Z","comments":true,"path":"2018-06-28/security/记一次XSS漏洞(慕课网)/","link":"","permalink":"https://assert6.github.io/2018-06-28/security/%E8%AE%B0%E4%B8%80%E6%AC%A1XSS%E6%BC%8F%E6%B4%9E(%E6%85%95%E8%AF%BE%E7%BD%91)/","excerpt":"","text":"首先随便注册个账号进入到手记栏目, 也就是文章区 点击右侧的写文章 点击插入图片 关键来了: 图片描述这里, 是直接写入img标签的title字段的! 这里我们可以尝试拼接onload来触发js 而且最最傻逼的一点, SESSIONID 不是httpOnly, 意味着我们可以通过js 脚本读取到SESSIONID 随便发布一篇文章, 等待管理员审核 成功拿到管理员账号 更为讽刺的是, 该名管理员还在看XSS 安全视频… 2018年7月2日更新不用尝试了, 已经反馈给官方, 已修复","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://assert6.github.io/tags/XSS/"},{"name":"安全","slug":"安全","permalink":"https://assert6.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"【手把手教你】使用TCP Client 调用Swoft RPC 服务","slug":"swoft/使用TCP Client 调用Swoft RPC 服务","date":"2018-06-07T16:00:00.000Z","updated":"2023-09-25T02:53:40.058Z","comments":true,"path":"2018-06-07/swoft/使用TCP Client 调用Swoft RPC 服务/","link":"","permalink":"https://assert6.github.io/2018-06-07/swoft/%E4%BD%BF%E7%94%A8TCP%20Client%20%E8%B0%83%E7%94%A8Swoft%20RPC%20%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"前两篇教大家如何搭建和使用Swoft RPC 服务, 这里简单说一下用其他TCP 客户端如何调用Swoft 的RPC 服务 这里用swoole_client 举个例子 123456789101112131415161718$client = new \\swoole_client(SWOOLE_SOCK_TCP);if (! $client-&gt;connect(&#x27;192.168.1.214&#x27;, 8099, 0.5))&#123; return &quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\\n&quot;;&#125;$client-&gt;send(json_encode([ &quot;interface&quot; =&gt; &quot;App\\Lib\\MemberInterface&quot;, &quot;version&quot; =&gt; &quot;0&quot;, &quot;method&quot; =&gt; &quot;getMemberByID&quot;, &quot;params&quot; =&gt; [$mid],]).&quot;\\r\\n&quot;);// 旧版不需要追加\\r\\n$result = $client-&gt;recv();$client-&gt;close();return $result; 非常的简单易用, 但是需要注意一点: interface 参数是服务端带命名空间的类名, 跟客户端没任何关系, 完全取决于服务端把RPC 接口类放在哪儿…","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"【手把手教你】用Swoft 搭建微服务(TCP RPC)2","slug":"swoft/用Swoft 搭建微服务(TCP RPC)2","date":"2018-06-06T16:00:00.000Z","updated":"2023-09-25T02:53:40.058Z","comments":true,"path":"2018-06-06/swoft/用Swoft 搭建微服务(TCP RPC)2/","link":"","permalink":"https://assert6.github.io/2018-06-06/swoft/%E7%94%A8Swoft%20%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1(TCP%20RPC)2/","excerpt":"","text":"上一篇讲了如何用Swoft 搭建RPC 服务 本篇介绍如何使用微服务 微服务流程首先讲一下微服务的流程 弄清楚流程, 开发起来就行云流水 这是官方给出的目录结构 1234app/ - Lib/ // 服务的公共接口定义目录，里面通常只有php接口类 - Pool/ // 服务池配置，里面可以配置不同服务的连接池，参考里面的 UserServicePool - Services/ // 具体的服务接口实现类，里面的类通常实现了 Lib 中定义的接口 当然在多个服务中使用时， 要将lib库 app&#x2F;Lib移到一个公共的git仓库里，然后各个服务通过 composer 来获取使用 这里有3个目录 Lib 是接口, 也是客户端和服务端必须的, 用来规定数据结构, 一般由服务端提供 服务端还需要实现Services, 也就是相当于Model 层 客户端可以通过配置Pool 来调用对应的Services, 如同调用自身的Model 一样方便 整个流程不是很难理解, 但是官方把三个目录放在一起, 并且没有详细说明, 导致很多同学搞不清楚 下面我们来写一个例子试一下吧 定义一个接口 接口定义和普通接口完全一致，唯一不一样的是: 需要在类注释上定义类似 deferGetUser 方法，对应类里面方法 getUser 且首字母大写。这种 defer* 方法，一般用于业务延迟收包和并发使用。 这些方法是不需要实现的，仅用于提供IDE提示。内部调用逻辑由框架帮你完成 在app/Lib 新建接口文件MemberInterface 定义一个getMemberByID方法, 并且根据官方提示, 在接口注释里定义一个deferGetMemberByID 方法 12345678910111213&lt;?phpnamespace App\\Lib;use Swoft\\Core\\ResultInterface;/** * @method ResultInterface deferGetMemberByID(int $id) */interface MemberInterface&#123; public function getMemberByID(int $id);&#125; 这样就可以了, 新建的每个方法都要在接口注释里加一个同名的defer*方法, 用来做延迟收包方法 把接口文件复制到swoft-http的app/Lib里, 且之后接口文件若有变动, 都要报证相同 服务端实现Services接口定义好了, 下面我们在Services 里实现这个接口 在app/Services 新建类文件MemberService, 实现MemberInterface 接口, 并继承其注释 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Services;use App\\Lib\\MemberInterface;use Swoft\\Core\\ResultInterface;/** * @method ResultInterface deferGetMemberByID(int $id) * @Service() */class MemberService implements MemberInterface&#123; public function getMemberByID(int $id) &#123; // TODO: Implement getMemberByID() method. return [ &quot;小红&quot;, &quot;小红1&quot;, &quot;小红2&quot;, &quot;小红3&quot;, &quot;小红4&quot;, ][$id] ?? &quot;查无此人&quot;; &#125;&#125; 这里需要注意: 注解里的@Service()默认为0, 用来区分接口的不同版本 也就是你可以建多个类来实现这个接口, @Service(version=&quot;1.0.1&quot;) 版本号不同即可 客户端配置Pool服务端的Service实现就是这么简单 反倒是客户端的连接池实现有些麻烦 客户端连接池需要搞清两个问题: 连谁? 连什么? app/Pool/Config 是连接池配置文件, 来解决第一个问题 同一个连接我们可以用同一个连接池, 刚才在服务端只是新增了一个接口, 并不是新建了一个RPC 服务, 所以这里不需要改动(只是我懒) 下面来解决第二个问题, 连什么? 在app/Controller 里新建一个控制器MemberController 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\Controllers;use App\\Lib\\MemberInterface;use Swoft\\Http\\Server\\Bean\\Annotation\\Controller;use Swoft\\Http\\Server\\Bean\\Annotation\\RequestMapping;use Swoft\\Http\\Server\\Bean\\Annotation\\RequestMethod;use Swoft\\Rpc\\Client\\Bean\\Annotation\\Reference;/** * @Controller() */class MemberController&#123; /** * @Reference(name=&quot;user&quot;, version=&quot;0&quot;) * @var MemberInterface */ private $memberService; /** * @RequestMapping(route=&quot;/member/&#123;mid&#125;&quot;, method=&#123;RequestMethod::GET&#125;) * @return array */ public function getMemberByID(int $mid) &#123; $result = $this-&gt;memberService-&gt;getMemberByID($mid); return [$result]; &#125;&#125; 注意成员memberService 的注解 @Reference(name=&quot;user&quot;) 用来指定连接谁, user 是别名, 在app/Lib/UserServicePool.php 的@Pool注解里命名 @var MemberInterface 用来指定连接什么, 也就是哪个接口 version=&quot;0&quot; 用来指定该接口的某个版本, 在服务端Services 的注解里声明 测试打开连接http://127.0.0.1:9501/member/2成功!","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"【手把手教你】用Swoft 搭建微服务(TCP RPC)","slug":"swoft/用Swoft 搭建微服务(TCP RPC)","date":"2018-06-05T16:00:00.000Z","updated":"2023-09-25T02:53:40.058Z","comments":true,"path":"2018-06-05/swoft/用Swoft 搭建微服务(TCP RPC)/","link":"","permalink":"https://assert6.github.io/2018-06-05/swoft/%E7%94%A8Swoft%20%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1(TCP%20RPC)/","excerpt":"","text":"Swoft 是什么? Swoft 框架是首个基于Swoole 原生协程的新时代 PHP高性能协程全栈框架，内置协程网络服务器及常用的协程客户端，常驻内存，不依赖传统的 PHP-FPM 全异步非阻塞 IO 实现，以类似于同步客户端的写法实现异步客户端的使用，没有复杂的异步回调，没有繁琐的 yield，有类似 Go 语言的协程，灵活的注解 强大的全局依赖注入容器、完善的服务治理、灵活强大的 AOP、标准的 PSR 规范实现等 上面是官网描述, 感觉太官方, 我总结一下: 常驻内存 协程 学习曲线平滑 国内框架 开箱即用的RPC 如何搭建微服务?首先确保已经可以正确搭建Swoft, 不清楚的可以查看Swoft 官方文档 鉴于每个人的开发环境都不同, 这里选用官方Docker 作为开发环境 Docker下载地址&gt;&gt;&gt; 拉Docker 镜像1docker pull swoft/swoft 非常的简单这样就是成功了 为了方便理解 我们把swoft 复制两份 命名为swoft-rpc和swoft-http swoft-rpc只开启TCP 服务swoft-http只开启HTTP 服务 修改配置文件把根目录的.env.example复制一份为.env .env 文件为swoft 配置文件, 最高优先级(覆盖config 下配置) HTTP 用到的配置 1234567891011121314151617181920212223242526# ServerPFILE=/tmp/swoft.pidPNAME=php-swoftTCPABLE=false //是否同时启动TCP 服务器,这里用不到改为falseCRONABLE=falseAUTO_RELOAD=trueAUTO_REGISTER=false...# HTTPHTTP_HOST=0.0.0.0 //监听的网卡HTTP_PORT=80 //监听的端口HTTP_MODE=SWOOLE_PROCESS //不用管HTTP_TYPE=SWOOLE_SOCK_TCP //不用管...//mysql 和redis 略过# User service (demo service)USER_POOL_NAME=user //别名USER_POOL_URI=192.168.1.214:8099,192.168.1.214:8099 //负载均衡,URI填写为RPC 的地址,注意Docker和宿主之间的关系USER_POOL_MIN_ACTIVE=5 //下面都不用管USER_POOL_MAX_ACTIVE=10USER_POOL_MAX_WAIT=20USER_POOL_TIMEOUT=200USER_POOL_MAX_WAIT_TIME=3USER_POOL_MAX_IDLE_TIME=60USER_POOL_USE_PROVIDER=falseUSER_POOL_BALANCER=randomUSER_POOL_PROVIDER=consul RPC 用到的配置 1234567# TCPTCP_HOST=0.0.0.0 //监听的网卡TCP_PORT=8099 //监听的端口TCP_MODE=SWOOLE_PROCESS //不用管TCP_TYPE=SWOOLE_SOCK_TCP //不用管TCP_PACKAGE_MAX_LENGTH=2048 //最大链接数TCP_OPEN_EOF_CHECK=false //不用管 启动Docker 容器1docker run -it --rm -p 8099:8099 -v E:\\WWW\\swoft-rpc:/var/www/swoft swoft/swoft /bin/bash 这里用-it和-v方便调试这样就是成功启动了 启动RPC 服务1php bin/swoft rpc:start RPC 服务只需要单独启动TCP 服务器 有的同学RPC 和TCP 的关系可能还没弄清楚 这里RPC 服务和TCP 服务器可以类比为Web 服务和HTTP 服务器 监听HTTP 来实现Web 服务监听TCP 来实现RPC 服务 就这样理解吧这样就是成功启动了 启动Web服务也就是启动HTTP 服务器XD 新开一个终端来创建新容器 1docker run -it --rm -p 9501:80 -v E:\\WWW\\swoft-http:/var/www/swoft swoft/swoft /bin/bash 这里端口改成9501, 因为本地开发环境已经用了80了:b 1php bin/swoft server:start 因为在之前把自动开启TCP 服务器禁用了 所以显示Disabled 这样也就是成功了! 访问一下http://127.0.0.1:9501/看下有没有问题 没问题的话, 可以看下官方提供的RPC demo http://127.0.0.1:9501/rpc/call 大功告成! 是不是很简单! 这里只教大家如何搭建, 下一篇来理解如何使用RPC","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]}],"categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"入门到精通","slug":"入门到精通","permalink":"https://assert6.github.io/tags/%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://assert6.github.io/tags/ChatGPT/"},{"name":"OpenAI","slug":"OpenAI","permalink":"https://assert6.github.io/tags/OpenAI/"},{"name":"Box","slug":"Box","permalink":"https://assert6.github.io/tags/Box/"},{"name":"Windows","slug":"Windows","permalink":"https://assert6.github.io/tags/Windows/"},{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"},{"name":"XSS","slug":"XSS","permalink":"https://assert6.github.io/tags/XSS/"},{"name":"安全","slug":"安全","permalink":"https://assert6.github.io/tags/%E5%AE%89%E5%85%A8/"}]}