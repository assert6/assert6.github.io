{"meta":{"title":"断言说","subtitle":"断言怎么说","description":"","author":"张城铭","url":"https://assert6.github.io","root":"/"},"pages":[{"title":"","date":"2023-02-14T10:01:27.079Z","updated":"2023-02-14T10:01:27.079Z","comments":true,"path":"about/index.html","permalink":"https://assert6.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-14T10:01:27.079Z","updated":"2023-02-14T10:01:27.079Z","comments":true,"path":"tags/index.html","permalink":"https://assert6.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"遇到的新问题 , 先挖坑","slug":"TODO","date":"2023-02-14T10:01:27.071Z","updated":"2023-02-14T10:01:27.071Z","comments":true,"path":"2023-02-14/TODO/","link":"","permalink":"https://assert6.github.io/2023-02-14/TODO/","excerpt":"","text":"声波牵引束 WebGL 挖矿 隐写术 casperjs","categories":[],"tags":[]},{"title":"一分钟搭建Hyperf","slug":"一分钟搭建Hyperf","date":"2019-07-10T16:00:00.000Z","updated":"2023-02-14T10:01:27.079Z","comments":true,"path":"2019-07-10/一分钟搭建Hyperf/","link":"","permalink":"https://assert6.github.io/2019-07-10/%E4%B8%80%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BAHyperf/","excerpt":"","text":"前置依赖 Docker Git PHPStorm 计时开始1.下载Hyperf Docker 镜像1docker pull hyperf/hyperf 2.下载Hyperf1git clone https://github.com/hyperf/hyperf-skeleton.git 3.等待下载完成 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 98% 4.配置PHPStorm打开hyperf-skeleton, 如下图所示配置PHPStorm 如果Server 选项里无法找到Docker,可能是Docker 没有暴露守护进程 点击配置旁边的运行按钮, 如下图示说明容器已经欢快的运行起来了 5.安装Composer 组件进入刚才部署的容器 1docker exec -it hyperf /bin/bash 进入容器后运行 1cd /home &amp;&amp; composer install 这一步到了安装Hyperf 组件的界面, 有需要的可以选择安装, 不需要可以全选n 安装完成后运行php bin/hyperf.php start, 然后打开浏览器请求http://127.0.0.1:9501 完成! 6.最后配置中的Command修改为php /home/bin/hyperf.php start, 就可以愉快的一键重启了","categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"}]},{"title":"【手把手教你】Swoft 多库连接池配置","slug":"swoft/Swoft 多库连接池配置","date":"2018-09-26T16:00:00.000Z","updated":"2023-02-14T10:01:27.075Z","comments":true,"path":"2018-09-26/swoft/Swoft 多库连接池配置/","link":"","permalink":"https://assert6.github.io/2018-09-26/swoft/Swoft%20%E5%A4%9A%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE/","excerpt":"","text":"这里的多库是指数据不同的两个主库 并不是数据相同的主从库 多库的配置非常简单, 只涉及到配置文件和两个类PoolConfig Pool 配置文件编辑配置文件 config/properties/db.php新增数据库配置 1234567891011121314&#x27;dev&#x27; =&gt; [ &#x27;master&#x27; =&gt; [ &#x27;name&#x27; =&gt; &#x27;master2&#x27;, &#x27;uri&#x27; =&gt; [ &#x27;192.168.1.135:3306/test?user=tender&amp;password=123456&amp;charset=utf8&#x27;, ], ], &#x27;slave&#x27; =&gt; [ &#x27;name&#x27; =&gt; &#x27;slave3&#x27;, &#x27;uri&#x27; =&gt; [ &#x27;192.168.1.135:3306/test?user=tender&amp;password=123456&amp;charset=utf8&#x27;, ], ],], 加完如下 默认的master和slave应为default下的配置, 为了兼容历史版本 连接池配置类新建app/Pool/Config/DevPoolConfig.php 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Pool\\Config;use Swoft\\Bean\\Annotation\\Bean;use Swoft\\Bean\\Annotation\\Value;use Swoft\\Db\\Pool\\Config\\DbPoolProperties;/** * DevPoolConfig * @Bean() */class DevPoolConfig extends DbPoolProperties&#123; /** * @Value(name=&quot;$&#123;config.db.dev.master.name&#125;&quot;) * @var string */ protected $name = &#x27;&#x27;; /** * @Value(name=&quot;$&#123;config.db.dev.master.uri&#125;&quot;) * @var array */ protected $uri = [];&#125; 连接池配置类只是把配置文件由数组改写为类, 有其他配置需要全部加进去。 这里只改了name 和uri 连接池新建app/Pool/DevPool.php 12345678910111213141516171819202122&lt;?phpnamespace App\\Pool;use App\\Pool\\Config\\DevPoolConfig;use Swoft\\Bean\\Annotation\\Inject;use Swoft\\Bean\\Annotation\\Pool;use Swoft\\Db\\Pool\\DbPool;/** * DevPool * * @Pool(&quot;dev.master&quot;) */class DevPool extends DbPool&#123; /** * @Inject() * @var DevPoolConfig */ public $poolConfig;&#125; 更简单, 指定该连接池使用哪个配置注意下@Pool 注解连接池别名, 要带.master或者.salve 使用连接池有两种方法使用连接池第一种是在实体类@Entity 注解里配置instance字段: 12345678/** * 用户实体 * @Entity(instance=&quot;dev.master&quot;) * @Table(name=&quot;user&quot;) */class User extends Model&#123;... 这样调用该实体就会走dev的配置 第二种是在Db::query() 查询时指定连接池, 直接在方法第三个参数配置即可: 1Db::query(&quot;show databases;&quot;,[], &#x27;dev.master&#x27;)-&gt;getResult();","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"【手把手教你】自定义Swoft 注解和AOP","slug":"swoft/自定义Swoft 注解和AOP","date":"2018-07-19T16:00:00.000Z","updated":"2023-02-14T10:01:27.075Z","comments":true,"path":"2018-07-19/swoft/自定义Swoft 注解和AOP/","link":"","permalink":"https://assert6.github.io/2018-07-19/swoft/%E8%87%AA%E5%AE%9A%E4%B9%89Swoft%20%E6%B3%A8%E8%A7%A3%E5%92%8CAOP/","excerpt":"","text":"序言前两篇关于Swoft RPC 的使用教程得到很多小伙伴的支持 并且反映网上很多关于Swoft 的讲解太过于深♂入, 很多小伙伴看不懂 这是很正常的, 因为开发者们对于使用难度的理解跟我们有些偏差 身为开发者自然知道如何使用, 认为不需要讲解, 也就是所谓的知识的诅咒 所以很多关于Swoft 的讲解都是底层原理 那在这我就开一个大佬们不屑的新手向讲解教程 (￣_ ￣ ) 叫做[手把手教你]系列 只要跟着一点点练习, 熟练使用是没问题滴 前置技能 会使用Swoft 的MVC 使用了Swoft 的注解 理解注解只是配置的另一种展现方式 PHPStorm 安装了PHP Annotations 插件 下面就让我们开始吧 注解类想要定义一个注解是非常简单的 新建注解类app\\Module\\Test\\Annotations\\Test.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Module\\Test\\Annotations;/** * 测试注解 * @Annotation * @Target(&quot;ALL&quot;) */class Test&#123; /** * @var string 构造参数 */ private $name = &#x27;&#x27;; public function __construct(array $values) &#123; if (isset($values[&#x27;name&#x27;])) &#123; $this-&gt;name = $values[&#x27;name&#x27;]; &#125; &#125; /** * @return string */ public function getName(): string &#123; return $this-&gt;name; &#125; /** * @param string $name */ public function setName(string $name) &#123; $this-&gt;name = $name; &#125;&#125; 这里有三点需要注意: 1 类注解要加@Annotation, 用来声明这是一个注解类 2 类名不需要加Annotation后缀 3 类注解@Target()为Doctrine\\Common\\Annotations\\Annotation\\Target.php, 参数可以填ALL|CLASS|METHOD|PROPERTY|ANNOTATION, 表示该注解使用的级别, 类注解还是方法注解,属性注解,或者全部都能使用 这样我们自定义的注解标签就完成了 去IndexController.php里试一下 注意不要忘记use我们的注解类 注解类Test的@Target设置为ALL, 可以同时在类和方法上使用(属性也可以的) 为了体现使用了注解, 可以在注解类Test的构造函数中进行输出 重启一下程序 这样就是成功了, 输出多个是正常现象, 毕竟多进程, 也是Swoft高性能的原因 注解解析类 Parser正如前置技能里所说 注解只是配置的另一种展现方式 任何逻辑都不要在注解类里处理 新建注解解析类app\\Module\\Test\\Parser\\TestParser.php 1234567891011121314151617181920&lt;?phpnamespace App\\Module\\Test\\Parser;use App\\Module\\Test\\Collector\\TestCollector;use Swoft\\Bean\\Parser\\AbstractParser;class TestParser extends AbstractParser&#123; public function parser( string $className, $objectAnnotation = null, string $propertyName = &#x27;&#x27;, string $methodName = &#x27;&#x27;, $propertyValue = null ) &#123; TestCollector::collect($className, $objectAnnotation, $propertyName, $methodName, $propertyValue); &#125;&#125; 解释一下这几个参数的意义: $className 当前注解所在的类名 $objectAnnotation 当前注解所实例化的注解类new Test([name=&quot;666&quot;]) $propertyName 当前注解所在的属性名(如果是属性注解) $methodName 当前注解所在的方法名(如果是方法注解) $propertyValue 当前注解所在的属性(如果是属性注解) 这里也不要处理逻辑, 因为此刻程序还处于初始化阶段, 没有请求数据 注解解析类Parser只做了一件事, 就是把注解类存入注解收集类 什么是注解收集类呢? 注解收集类 Collector注解收集类Collector非常简单, 相当于一个全局数组方便我们后续处理而已 新建注解收集类app\\Module\\Test\\Collector\\TestCollector.php 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Module\\Test\\Collector;use Swoft\\Bean\\CollectorInterface;class TestCollector implements CollectorInterface&#123; private static $test = []; public static function collect( string $className, $objectAnnotation = null, string $propertyName = &#x27;&#x27;, string $methodName = &#x27;&#x27;, $propertyValue = null ) &#123; self::$test[$className][$methodName] = $objectAnnotation; &#125; public static function getCollector() &#123; return self::$test; &#125;&#125; 正如所见, 只是存取$objectAnnotation注解实例, 方便我们后面使用 本篇举例的是方法注解, 所以默认$methodName不为空 注解收集类Collector被注解解析类Parser调用 那注解解析类Parser被谁调用呢? 注解封装类 Wrapper新建注解封装类app\\Module\\Test\\Wrapper\\TestWrapper.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace App\\Module\\Test\\Wrapper;use App\\Module\\Test\\Annotations\\Test;use Swoft\\Bean\\Wrapper\\AbstractWrapper;class TestWrapper extends AbstractWrapper&#123; /** * @var array 解析哪些注解(类级) */ protected $classAnnotations = []; /** * @var array 解析哪些注解(属性级) */ protected $propertyAnnotations = []; /** * @var array 解析哪些注解(方法级) */ protected $methodAnnotations = [ Test::class, ]; /** * 是否解析类注解 * @param array $annotations * @return bool */ public function isParseClassAnnotations(array $annotations): bool &#123; return false; &#125; /** * 是否解析属性注解 * @param array $annotations * @return bool */ public function isParsePropertyAnnotations(array $annotations): bool &#123; return false; &#125; /** * 是否解析方法注解 * @param array $annotations * @return bool */ public function isParseMethodAnnotations(array $annotations): bool &#123; return true; &#125;&#125; 当我们的类注解被实例化时, 会触发注解封装类&#123;注解标签名&#125;Wrapper 注解封装类Wrapper来决定是否触发注解解析类Parser 解释一下, 可能不好理解 这里isParseClassAnnotations 返回false, 意味着类注解略过不解析; 同理isParsePropertyAnnotations 返回false, 属性注解略过不解析; 而isParseMethodAnnotations 返回true,那么对应的$methodAnnotations里的注解类全部触发解析,这里的Test::class会触发对应的TestParser; 抽象的说, 注解封装类Wrapper回答了两个问题: 是否解析, 解析哪些 具象的说, 这里的封装类TestWrapper回答的就是:”只解析方法注解@Test“ 可以在注解解析类Parser的构造方法中进行输出 重启程序, 我们来看一下!这里可以看到, 在注解类Test里输出的内容还有类注解的666, 到了注解解析类TestParser, 就没有了666, 只有方法注解777 总结 实例化注解类Test, 询问注解封装类TestWrapper解析哪些注解 注解封装类TestWrapper回答解析方法上的Test, 于是方法级的注解Test被注解解析类TestParser存进了注解收集类TestCollector 注意!!!!程序只会主动扫描类注解, 然后扫描类注解Wrapper下指定的方法注解和属性注解!!如果你的方法注解不存在于任何类注解的Wrapper下, 则是不会被解析的!!如何使用收集完毕下面举例如何使用 中间件新建中间件app\\Module\\Test\\Middlewares\\TestMiddleware.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Module\\Test\\Middlewares;use App\\Module\\Test\\Annotations\\Test;use App\\Module\\Test\\Collector\\TestCollector;use Psr\\Http\\Message\\ResponseInterface;use Psr\\Http\\Message\\ServerRequestInterface;use Psr\\Http\\Server\\RequestHandlerInterface;use Swoft\\Bean\\Annotation\\Bean;use Swoft\\Core\\RequestContext;use Swoft\\Http\\Message\\Middleware\\MiddlewareInterface;/** * @Bean() */class TestMiddleware implements MiddlewareInterface&#123; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface &#123; echo &quot;in Middleware\\n&quot;; $response = $handler-&gt;handle($request); // 当前请求的控制器 $controllerClass = RequestContext::getContextDataByKey(&#x27;controllerClass&#x27;); // 当前请求的方法 $controllerAction = RequestContext::getContextDataByKey(&#x27;controllerAction&#x27;); $collector = TestCollector::getCollector(); /* @var Test $test*/ if ($test = $collector[$controllerClass][$controllerAction])&#123; print_r($test-&gt;getName().&quot; in Middleware\\n&quot;); &#125; return $response; &#125;&#125; 这里可以看到, 之前负责收集注解的注解收集类TestCollector 派上用处了, 可以非常方便的通过他获取到当前请求方法的注解信息 这需要注意, RequestContext::getContextDataByKey(&#39;controllerClass&#39;)获取请求控制器的方法要在$handler-&gt;handle($request)后才有值, 因为负责路由的中间件还没执行到XD 切勿忘记use 中间件 重启完访问一下试试 AOP 切面新建切面类app\\Module\\Test\\Aspect\\TestAspect.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace App\\Module\\Test\\Aspect;use App\\Module\\Test\\Collector\\TestCollector;use Swoft\\Aop\\ProceedingJoinPoint;use Swoft\\Bean\\Annotation\\Around;use Swoft\\Bean\\Annotation\\Aspect;use Swoft\\Bean\\Annotation\\PointAnnotation;use App\\Module\\Test\\Annotations\\Test;use Swoft\\Core\\RequestContext;/** * 测试切面类 * @Aspect() * @PointAnnotation( * include=&#123; * Test::class * &#125; * ) * @package App\\Module\\Test\\Aspect */class TestAspect&#123; /** * @Around() * @param ProceedingJoinPoint $proceedingJoinPoint * @return mixed */ public function around(ProceedingJoinPoint $proceedingJoinPoint) &#123; $controllerClass = RequestContext::getContextDataByKey(&#x27;controllerClass&#x27;); $controllerAction = RequestContext::getContextDataByKey(&#x27;controllerAction&#x27;); $collector = TestCollector::getCollector(); /* @var Test $test*/ $test = $collector[$controllerClass][$controllerAction]; echo $test-&gt;getName(), &quot;around-before\\n&quot;; $result = $proceedingJoinPoint-&gt;proceed(); echo $test-&gt;getName(), &quot;around-after\\n&quot;; return $result; &#125;&#125; @Aspect() 声明这是一个切面类 @PointAnnotation 设置了注解切入点 @Before() 设置了通知点 其他设置可以参考Swoft文档 AOP章节; 还需要改一下注解解析类TestParser 在parser 方法中加入Collector::$methodAnnotations[$className][$methodName][] = get_class($objectAnnotation); 这一步的作用是将使用注解的方法加入到允许切入的数组, 只有在Collector::$methodAnnotations变量中存在的方法才会调用切面 重启程序请求一下 控制器当然也可以在控制器用 个人还是推荐用切面, 控制器里只需要加入注解即可","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"记一次XSS漏洞(慕课网)","slug":"security/记一次XSS漏洞(慕课网)","date":"2018-06-28T16:00:00.000Z","updated":"2023-02-14T10:01:27.071Z","comments":true,"path":"2018-06-28/security/记一次XSS漏洞(慕课网)/","link":"","permalink":"https://assert6.github.io/2018-06-28/security/%E8%AE%B0%E4%B8%80%E6%AC%A1XSS%E6%BC%8F%E6%B4%9E(%E6%85%95%E8%AF%BE%E7%BD%91)/","excerpt":"","text":"首先随便注册个账号进入到手记栏目, 也就是文章区 点击右侧的写文章 点击插入图片 关键来了: 图片描述这里, 是直接写入img标签的title字段的! 这里我们可以尝试拼接onload来触发js 而且最最傻逼的一点, SESSIONID 不是httpOnly, 意味着我们可以通过js 脚本读取到SESSIONID 随便发布一篇文章, 等待管理员审核 成功拿到管理员账号 更为讽刺的是, 该名管理员还在看XSS 安全视频… 2018年7月2日更新不用尝试了, 已经反馈给官方, 已修复","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://assert6.github.io/tags/XSS/"},{"name":"安全","slug":"安全","permalink":"https://assert6.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"【手把手教你】使用TCP Client 调用Swoft RPC 服务","slug":"swoft/使用TCP Client 调用Swoft RPC 服务","date":"2018-06-07T16:00:00.000Z","updated":"2023-02-14T10:01:27.075Z","comments":true,"path":"2018-06-07/swoft/使用TCP Client 调用Swoft RPC 服务/","link":"","permalink":"https://assert6.github.io/2018-06-07/swoft/%E4%BD%BF%E7%94%A8TCP%20Client%20%E8%B0%83%E7%94%A8Swoft%20RPC%20%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"前两篇教大家如何搭建和使用Swoft RPC 服务, 这里简单说一下用其他TCP 客户端如何调用Swoft 的RPC 服务 这里用swoole_client 举个例子 123456789101112131415161718$client = new \\swoole_client(SWOOLE_SOCK_TCP);if (! $client-&gt;connect(&#x27;192.168.1.214&#x27;, 8099, 0.5))&#123; return &quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\\n&quot;;&#125;$client-&gt;send(json_encode([ &quot;interface&quot; =&gt; &quot;App\\Lib\\MemberInterface&quot;, &quot;version&quot; =&gt; &quot;0&quot;, &quot;method&quot; =&gt; &quot;getMemberByID&quot;, &quot;params&quot; =&gt; [$mid],]).&quot;\\r\\n&quot;);// 旧版不需要追加\\r\\n$result = $client-&gt;recv();$client-&gt;close();return $result; 非常的简单易用, 但是需要注意一点: interface 参数是服务端带命名空间的类名, 跟客户端没任何关系, 完全取决于服务端把RPC 接口类放在哪儿…","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"【手把手教你】用Swoft 搭建微服务(TCP RPC)2","slug":"swoft/用Swoft 搭建微服务(TCP RPC)2","date":"2018-06-06T16:00:00.000Z","updated":"2023-02-14T10:01:27.075Z","comments":true,"path":"2018-06-06/swoft/用Swoft 搭建微服务(TCP RPC)2/","link":"","permalink":"https://assert6.github.io/2018-06-06/swoft/%E7%94%A8Swoft%20%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1(TCP%20RPC)2/","excerpt":"","text":"上一篇讲了如何用Swoft 搭建RPC 服务 本篇介绍如何使用微服务 微服务流程首先讲一下微服务的流程 弄清楚流程, 开发起来就行云流水 这是官方给出的目录结构 1234app/ - Lib/ // 服务的公共接口定义目录，里面通常只有php接口类 - Pool/ // 服务池配置，里面可以配置不同服务的连接池，参考里面的 UserServicePool - Services/ // 具体的服务接口实现类，里面的类通常实现了 Lib 中定义的接口 当然在多个服务中使用时， 要将lib库 app&#x2F;Lib移到一个公共的git仓库里，然后各个服务通过 composer 来获取使用 这里有3个目录 Lib 是接口, 也是客户端和服务端必须的, 用来规定数据结构, 一般由服务端提供 服务端还需要实现Services, 也就是相当于Model 层 客户端可以通过配置Pool 来调用对应的Services, 如同调用自身的Model 一样方便 整个流程不是很难理解, 但是官方把三个目录放在一起, 并且没有详细说明, 导致很多同学搞不清楚 下面我们来写一个例子试一下吧 定义一个接口 接口定义和普通接口完全一致，唯一不一样的是: 需要在类注释上定义类似 deferGetUser 方法，对应类里面方法 getUser 且首字母大写。这种 defer* 方法，一般用于业务延迟收包和并发使用。 这些方法是不需要实现的，仅用于提供IDE提示。内部调用逻辑由框架帮你完成 在app/Lib 新建接口文件MemberInterface 定义一个getMemberByID方法, 并且根据官方提示, 在接口注释里定义一个deferGetMemberByID 方法 12345678910111213&lt;?phpnamespace App\\Lib;use Swoft\\Core\\ResultInterface;/** * @method ResultInterface deferGetMemberByID(int $id) */interface MemberInterface&#123; public function getMemberByID(int $id);&#125; 这样就可以了, 新建的每个方法都要在接口注释里加一个同名的defer*方法, 用来做延迟收包方法 把接口文件复制到swoft-http的app/Lib里, 且之后接口文件若有变动, 都要报证相同 服务端实现Services接口定义好了, 下面我们在Services 里实现这个接口 在app/Services 新建类文件MemberService, 实现MemberInterface 接口, 并继承其注释 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Services;use App\\Lib\\MemberInterface;use Swoft\\Core\\ResultInterface;/** * @method ResultInterface deferGetMemberByID(int $id) * @Service() */class MemberService implements MemberInterface&#123; public function getMemberByID(int $id) &#123; // TODO: Implement getMemberByID() method. return [ &quot;小红&quot;, &quot;小红1&quot;, &quot;小红2&quot;, &quot;小红3&quot;, &quot;小红4&quot;, ][$id] ?? &quot;查无此人&quot;; &#125;&#125; 这里需要注意: 注解里的@Service()默认为0, 用来区分接口的不同版本 也就是你可以建多个类来实现这个接口, @Service(version=&quot;1.0.1&quot;) 版本号不同即可 客户端配置Pool服务端的Service实现就是这么简单 反倒是客户端的连接池实现有些麻烦 客户端连接池需要搞清两个问题: 连谁? 连什么? app/Pool/Config 是连接池配置文件, 来解决第一个问题 同一个连接我们可以用同一个连接池, 刚才在服务端只是新增了一个接口, 并不是新建了一个RPC 服务, 所以这里不需要改动(只是我懒) 下面来解决第二个问题, 连什么? 在app/Controller 里新建一个控制器MemberController 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\Controllers;use App\\Lib\\MemberInterface;use Swoft\\Http\\Server\\Bean\\Annotation\\Controller;use Swoft\\Http\\Server\\Bean\\Annotation\\RequestMapping;use Swoft\\Http\\Server\\Bean\\Annotation\\RequestMethod;use Swoft\\Rpc\\Client\\Bean\\Annotation\\Reference;/** * @Controller() */class MemberController&#123; /** * @Reference(name=&quot;user&quot;, version=&quot;0&quot;) * @var MemberInterface */ private $memberService; /** * @RequestMapping(route=&quot;/member/&#123;mid&#125;&quot;, method=&#123;RequestMethod::GET&#125;) * @return array */ public function getMemberByID(int $mid) &#123; $result = $this-&gt;memberService-&gt;getMemberByID($mid); return [$result]; &#125;&#125; 注意成员memberService 的注解 @Reference(name=&quot;user&quot;) 用来指定连接谁, user 是别名, 在app/Lib/UserServicePool.php 的@Pool注解里命名 @var MemberInterface 用来指定连接什么, 也就是哪个接口 version=&quot;0&quot; 用来指定该接口的某个版本, 在服务端Services 的注解里声明 测试打开连接http://127.0.0.1:9501/member/2成功!","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]},{"title":"【手把手教你】用Swoft 搭建微服务(TCP RPC)","slug":"swoft/用Swoft 搭建微服务(TCP RPC)","date":"2018-06-05T16:00:00.000Z","updated":"2023-02-14T10:01:27.075Z","comments":true,"path":"2018-06-05/swoft/用Swoft 搭建微服务(TCP RPC)/","link":"","permalink":"https://assert6.github.io/2018-06-05/swoft/%E7%94%A8Swoft%20%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1(TCP%20RPC)/","excerpt":"","text":"Swoft 是什么? Swoft 框架是首个基于Swoole 原生协程的新时代 PHP高性能协程全栈框架，内置协程网络服务器及常用的协程客户端，常驻内存，不依赖传统的 PHP-FPM 全异步非阻塞 IO 实现，以类似于同步客户端的写法实现异步客户端的使用，没有复杂的异步回调，没有繁琐的 yield，有类似 Go 语言的协程，灵活的注解 强大的全局依赖注入容器、完善的服务治理、灵活强大的 AOP、标准的 PSR 规范实现等 上面是官网描述, 感觉太官方, 我总结一下: 常驻内存 协程 学习曲线平滑 国内框架 开箱即用的RPC 如何搭建微服务?首先确保已经可以正确搭建Swoft, 不清楚的可以查看Swoft 官方文档 鉴于每个人的开发环境都不同, 这里选用官方Docker 作为开发环境 Docker下载地址&gt;&gt;&gt; 拉Docker 镜像1docker pull swoft/swoft 非常的简单这样就是成功了 为了方便理解 我们把swoft 复制两份 命名为swoft-rpc和swoft-http swoft-rpc只开启TCP 服务swoft-http只开启HTTP 服务 修改配置文件把根目录的.env.example复制一份为.env .env 文件为swoft 配置文件, 最高优先级(覆盖config 下配置) HTTP 用到的配置 1234567891011121314151617181920212223242526# ServerPFILE=/tmp/swoft.pidPNAME=php-swoftTCPABLE=false //是否同时启动TCP 服务器,这里用不到改为falseCRONABLE=falseAUTO_RELOAD=trueAUTO_REGISTER=false...# HTTPHTTP_HOST=0.0.0.0 //监听的网卡HTTP_PORT=80 //监听的端口HTTP_MODE=SWOOLE_PROCESS //不用管HTTP_TYPE=SWOOLE_SOCK_TCP //不用管...//mysql 和redis 略过# User service (demo service)USER_POOL_NAME=user //别名USER_POOL_URI=192.168.1.214:8099,192.168.1.214:8099 //负载均衡,URI填写为RPC 的地址,注意Docker和宿主之间的关系USER_POOL_MIN_ACTIVE=5 //下面都不用管USER_POOL_MAX_ACTIVE=10USER_POOL_MAX_WAIT=20USER_POOL_TIMEOUT=200USER_POOL_MAX_WAIT_TIME=3USER_POOL_MAX_IDLE_TIME=60USER_POOL_USE_PROVIDER=falseUSER_POOL_BALANCER=randomUSER_POOL_PROVIDER=consul RPC 用到的配置 1234567# TCPTCP_HOST=0.0.0.0 //监听的网卡TCP_PORT=8099 //监听的端口TCP_MODE=SWOOLE_PROCESS //不用管TCP_TYPE=SWOOLE_SOCK_TCP //不用管TCP_PACKAGE_MAX_LENGTH=2048 //最大链接数TCP_OPEN_EOF_CHECK=false //不用管 启动Docker 容器1docker run -it --rm -p 8099:8099 -v E:\\WWW\\swoft-rpc:/var/www/swoft swoft/swoft /bin/bash 这里用-it和-v方便调试这样就是成功启动了 启动RPC 服务1php bin/swoft rpc:start RPC 服务只需要单独启动TCP 服务器 有的同学RPC 和TCP 的关系可能还没弄清楚 这里RPC 服务和TCP 服务器可以类比为Web 服务和HTTP 服务器 监听HTTP 来实现Web 服务监听TCP 来实现RPC 服务 就这样理解吧这样就是成功启动了 启动Web服务也就是启动HTTP 服务器XD 新开一个终端来创建新容器 1docker run -it --rm -p 9501:80 -v E:\\WWW\\swoft-http:/var/www/swoft swoft/swoft /bin/bash 这里端口改成9501, 因为本地开发环境已经用了80了:b 1php bin/swoft server:start 因为在之前把自动开启TCP 服务器禁用了 所以显示Disabled 这样也就是成功了! 访问一下http://127.0.0.1:9501/看下有没有问题 没问题的话, 可以看下官方提供的RPC demo http://127.0.0.1:9501/rpc/call 大功告成! 是不是很简单! 这里只教大家如何搭建, 下一篇来理解如何使用RPC","categories":[],"tags":[{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"}]}],"categories":[],"tags":[{"name":"Hyperf","slug":"Hyperf","permalink":"https://assert6.github.io/tags/Hyperf/"},{"name":"手把手教你","slug":"手把手教你","permalink":"https://assert6.github.io/tags/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0/"},{"name":"Swoft","slug":"Swoft","permalink":"https://assert6.github.io/tags/Swoft/"},{"name":"XSS","slug":"XSS","permalink":"https://assert6.github.io/tags/XSS/"},{"name":"安全","slug":"安全","permalink":"https://assert6.github.io/tags/%E5%AE%89%E5%85%A8/"}]}